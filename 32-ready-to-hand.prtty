.waypoint[name=part2b]
.slide
    .vcenter
        .center
            .style[fg=$lowlight] << Part 2b
        .nl < .nl
        .style[bold]
            .center << ready-to-hand
            .nl
            .center << vs
            .nl
            .center << present-at-hand


.slide
    .exec[cmd="timg -E -gx14 ./images/being_and_time.jpg"]
    .vcenter
        .moveTo[x=25]
        > Martin Heidegger
        .vspace[lines=2]
        .moveTo[x=25]
        > Sein und Zeit (Being and Time)
        .moveTo[x=25]
        .style[fg=$lowlight] << 1927

.slide
    .vcenter
        We normally encounter objects as 
        .style[fg=$highlight;bold] << ready-to-hand
        .nl
        
        .wait
        .vspace[lines=3]
        > We consider them in terms of trying to achieve
        > some other task

        .wait
        .vspace[lines=3]
        We don't normally consider objects 
        .alternate
            independently
            theoretically

.slide
    .center << Consider a hammer

    .wait
    .moveTo[y=2]
    .exec[cmd="timg -E -gx11 ./images/hammer.jpg"]
    
    .wait
    .moveTo[y=3;x=25]
    > We normally consider a hammer
    .moveTo[x=25]
    > in terms of hammering something

    .wait
    .nl
    .moveTo[x=25]
    > We don't think about how it 
    .moveTo[x=25]
    > is constructed

    .wait
    .nl
    .moveTo[x=25]
    > We don't think about what it
    .moveTo[x=25]
    .style[fg=$highlight] << means to be a hammer


    .wait
    .moveTo[y=3;x=25]
    "                              "
    .nl < .moveTo[x=25]
    "                                "
    .nl < .nl < .moveTo[x=25]
    "                             "
    .nl < .moveTo[x=25]
    "                "
    .nl < .nl < .moveTo[x=25]
    "                             "
    .nl < .moveTo[x=25]
    "                    "

    .moveTo[y=3;x=25]
    > If it breaks
    .wait
    .moveTo[x=25]
    > we forget about hammering.

    .wait
    .nl
    .moveTo[x=25]
    > We become aware of
    .moveTo[x=25]
    > the hammer itself.

    .wait
    .nl
    .moveTo[x=25]
    > The hammer becomes 
    .moveTo[x=25]
    .style[fg=$highlight]
        > present-at-hand

.slide
    .center << Consider a for loop

    .vspace[lines=3]
    .style[fg=$code]
        .type
            > for _, u := range users {
            >     // ...   
            > }

    .wait
    .vspace[lines=2]
    > We normally consider it in terms of 
    > doing something repeatedly

    .wait
    .nl
    > We don't think about how it is implemented

    .wait
    .nl
    We don't think about 
    .style[fg=$highlight] << what a for loop is

.slide
    .middle
        A 
        .style[fg=$highlight] << for loop 
        is ready-to-hand

.slide
    .middle
        What about generics?

    .wait
    .backspace << generics?
    .alternate
        patterns?
        monads?

    .wait
    .vspace[lines=3]
    .center << It depends how familiar we are with them

.slide
    .vcenter
        Unfamiliar abstractions are
        .nl
        .style[fg=$highlight] << present-at-hand

        .wait
        .vspace[lines=3]
        Broken abstractions are
        .nl
        .style[fg=$highlight] << present-at-hand

        .wait
        .vspace[lines=3]
        "... and "
        .style[fg=$highlight] << present-at-hand 
        abstractions
        .nl
        are bad abstractions

        .wait
        .vspace[lines=3]
        They distract us from what we're trying to do.

.slide
    .vcenter
        Unfamilar abstractions can become
        .nl
        .style[fg=$highlight] << familiar

        .wait
        .nl
        through education and practice

        .wait
        .vspace[lines=3]
        .style[fg=$highlight] << present-at-hand 
        abstractions

        .wait
        .moveTo[x=0]
        .style[fg=$lowlight] << present-at-hand
        .nl
        can become 
        .style[fg=$highlight] << .type << ready-to-hand

        .wait
        .vspace[lines=3]
        .style[fg=$lowlight] << (just don't forget to take your team with you)