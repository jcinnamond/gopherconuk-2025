.slide
    .vcenter
        .center
            .style[fg=$lowlight] << Part 2d
        .nl < .nl
        .style[bold]
            .center << Algebra

.slide
    .vcenter
        .quote[citation="Wikipedia"; altColor=$lowlight]
            Algebra is a branch of mathematics 
            that deals with abstract systems

.slide
    .vcenter
        > Algebra has been very influential in computer science
        > and, to a lesser extent, in programming.
        .vspace[lines=2]

        .wait
        From group theory 
        .style[fg=$lowlight] << e.g., 
        monoids, semi-rings, lattices
        .nl
        .wait
        From category theory 
        .style[fg=$lowlight] << e.g., 
        functors, monads, arrows
        .nl
        .wait
        From type theory 
        .style[fg=$lowlight] << e.g., 
        dependent types
        .nl

        .wait
        .vspace[lines=2]
        > I don't want to talk about particular algebras.

        .wait
        .vspace[lines=2]
        I want to talk about an aspect of how algebra 
        .style[fg=$highlight] << works

.slide
    .vcenter
        "... or rather, algebra doesn't "
        .style[fg=$highlight] << work

        .wait
        .vspace[lines=1]
        algebra 
        .style[fg=$highlight] << is

        .wait
        .vspace[lines=2]
        You don't 
        .style[fg=$highlight] << do 
        an algebra
        .wait
        .vspace[lines=1]
        You 
        .style[fg=$highlight] << recognise 
        it


.slide
    .vcenter
        .style[fg=$code]
            .type
                > type Filter = func(Product) bool

            .wait
            .vspace[lines=2]
            .type
                > func join(f1, f2 Filter) Filter {
                >     return func(p Product) {
                >         return f1(p) && f2(p)
                >     }
                > }

        .wait
        .vspace[lines=2]
        This is a monoid.

        .wait
        .vspace[lines=2]
        We haven't 
        .style[fg=$highlight] << used 
        a monoid.

        .wait
        .nl
        It just 
        .style[fg=$highlight] << is 
        one.

.slide
    .vcenter
        A 
        .style[bold] << monoid 
        consists of:
        .nl

        .style[fg=$code]
            >   A set 𝓢
            >   A binary operation 𝓢 ⨯ 𝓢 ⟶ 𝓢, denoted by *
        
        .vspace[lines=2]
        > satisfying two axioms
        .style[fg=$code]
            >   Associativity: ∀𝘢,𝘣,𝘤 ∈ 𝓢, (𝘢 * 𝘣) * 𝘤 = 𝘢 * (𝘣 * 𝘤)
            >   Identity: ∃𝘦 ∈ 𝓢, ∀a ∈ 𝓢, 𝘢 * 𝘦 = 𝘦 * 𝘢 = 𝘢

.slide
    .middle
        .style[fg=$lowlight] << ain't nobody got time for that

.slide
    .vcenter
        > It doesn't matter whether or not you 
        > know what a monoid is.

        .wait
        .vspace[lines=1]
        That doesn't change the fact that this 
        .style[fg=$highlight] << is 
        a monoid
        .vspace[lines=2]

        .style[fg=$code]
            > type Filter = func(Product) bool
            .vspace[lines=1]
            > func join(f1, f2 Filter) Filter {
            >     return func(p Product) {
            >         return f1(p) && f2(p)
            >     }
            > }

.slide
    .vcenter
        .quote[altColor=$lowlight] << This is a monoid

        .vspace[lines=2]
        .center
            This isn't a 
            .style[fg=$highlight] << judgement
        
        .wait
        .vspace[lines=2]
        .center
            We haven't done any 
            .style[fg=$highlight] << work 
        .nl
        .center
            to make it a monoid.

        .wait
        .vspace[lines=3]
        .center
            It's just reality

.slide
    .vcenter
        A lot of abstractions are like this in programming

        .vspace[lines=2]
        We don't 
        .style[fg=$highlight] << create 
        them.
        .nl

        We 
        .style[fg=$highlight] << recogise 
        them.

        .vspace[lines=2]
        > Their value comes in how they reveal truths
        > about our code
        .wait
        > ...and in how the allow us to use different 
        > structures in the same way

.slide
    .vcenter
        .style[fg=$lowlight] << e.g, 
        because I know this is a monoid...
        .vspace[lines=2]

        .style[fg=$code]
            > type Filter = func(Product) bool
            .vspace[lines=1]
            > func join(f1, f2 Filter) Filter {
            >     return func(p Product) {
            >         return f1(p) && f2(p)
            >     }
            > }

        .wait
        .vspace[lines=1]
        > I know I can collapse a list of 
        > filters into a single filter
        .wait
        .vspace[lines=1]
        That's just a consequence of it 
        .style[italic] << being a monoid

.slide
    .vcenter
        > Programming with abstractions
        > is about understanding your code
        > and recognising patterns within it.

        .wait
        .vspace[lines=3]
        .style[fg=$highlight] << Good 
        abstractions come from 
        .nl
        recognising patterns that are
        .nl
        .style[fg=$highlight] << useful 
        in some way.